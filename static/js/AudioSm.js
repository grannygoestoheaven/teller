// Autogenerated with StateSmith 0.19.0+b5719011215d41a81572ed347c02b22db5d1a48f.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class AudioSm
{
    static EventId = 
    {
        MUTE_AMBIENT : 0,
        MUTE_MUSIC : 1,
        PAUSE_ALL : 2,
        PLAY : 3,
        REPLAY : 4,
        RESUME_ALL : 5,
        SPEECH_READY : 6,
        UNMUTE_AMBIENT : 7,
        UNMUTE_MUSIC : 8,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 9;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        PLAYER : 1,
        IDLE : 2,
        LOADING : 3,
        PAUSED : 4,
        PLAYING : 5,
        REPLAYING : 6,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 7;
    static { Object.freeze(this.StateIdCount); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: TransitionTo(PLAYER)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PLAYER`.
                this.#PLAYER_enter();
                
                // PLAYER.<InitialState> behavior
                // uml: TransitionTo(IDLE)
                {
                    // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `IDLE`.
                    this.#IDLE_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    return;
                } // end of behavior for PLAYER.<InitialState>
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: AudioSm
            case AudioSm.StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: PLAYER
            case AudioSm.StateId.PLAYER:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: IDLE
            case AudioSm.StateId.IDLE:
                switch (eventId)
                {
                    case AudioSm.EventId.PLAY: this.#IDLE_play(); break;
                }
                break;
            
            // STATE: LOADING
            case AudioSm.StateId.LOADING:
                switch (eventId)
                {
                    case AudioSm.EventId.SPEECH_READY: this.#LOADING_speech_ready(); break;
                }
                break;
            
            // STATE: PAUSED
            case AudioSm.StateId.PAUSED:
                switch (eventId)
                {
                    case AudioSm.EventId.RESUME_ALL: this.#PAUSED_resume_all(); break;
                    case AudioSm.EventId.REPLAY: this.#PAUSED_replay(); break;
                }
                break;
            
            // STATE: PLAYING
            case AudioSm.StateId.PLAYING:
                switch (eventId)
                {
                    case AudioSm.EventId.MUTE_MUSIC: this.#PLAYING_mute_music(); break;
                    case AudioSm.EventId.UNMUTE_MUSIC: this.#PLAYING_unmute_music(); break;
                    case AudioSm.EventId.MUTE_AMBIENT: this.#PLAYING_mute_ambient(); break;
                    case AudioSm.EventId.UNMUTE_AMBIENT: this.#PLAYING_unmute_ambient(); break;
                    case AudioSm.EventId.PAUSE_ALL: this.#PLAYING_pause_all(); break;
                    case AudioSm.EventId.REPLAY: this.#PLAYING_replay(); break;
                }
                break;
            
            // STATE: REPLAYING
            case AudioSm.StateId.REPLAYING:
                switch (eventId)
                {
                    case AudioSm.EventId.SPEECH_READY: this.#REPLAYING_speech_ready(); break;
                }
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case AudioSm.StateId.PLAYER: this.#PLAYER_exit(); break;
                
                case AudioSm.StateId.IDLE: this.#IDLE_exit(); break;
                
                case AudioSm.StateId.LOADING: this.#LOADING_exit(); break;
                
                case AudioSm.StateId.PAUSED: this.#PAUSED_exit(); break;
                
                case AudioSm.StateId.PLAYING: this.#PLAYING_exit(); break;
                
                case AudioSm.StateId.REPLAYING: this.#REPLAYING_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        this.stateId = AudioSm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYER
    ////////////////////////////////////////////////////////////////////////////////
    
    #PLAYER_enter()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #PLAYER_exit()
    {
        this.stateId = AudioSm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IDLE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IDLE_enter()
    {
        this.stateId = AudioSm.StateId.IDLE;
        
        // IDLE behavior
        // uml: enter / { stopAll(); uiIdle(); }
        {
            // Step 1: execute action `stopAll(); uiIdle();`
            stopAll(); uiIdle();
        } // end of behavior for IDLE
    }
    
    #IDLE_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #IDLE_play()
    {
        // IDLE behavior
        // uml: PLAY TransitionTo(LOADING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#IDLE_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `LOADING`.
            this.#LOADING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IDLE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state LOADING
    ////////////////////////////////////////////////////////////////////////////////
    
    #LOADING_enter()
    {
        this.stateId = AudioSm.StateId.LOADING;
        
        // LOADING behavior
        // uml: enter / { startSpeech(); uiLoading(); }
        {
            // Step 1: execute action `startSpeech(); uiLoading();`
            startSpeech(); uiLoading();
        } // end of behavior for LOADING
    }
    
    #LOADING_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #LOADING_speech_ready()
    {
        // LOADING behavior
        // uml: SPEECH_READY TransitionTo(PLAYING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#LOADING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PLAYING`.
            this.#PLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for LOADING
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PAUSED
    ////////////////////////////////////////////////////////////////////////////////
    
    #PAUSED_enter()
    {
        this.stateId = AudioSm.StateId.PAUSED;
        
        // PAUSED behavior
        // uml: enter / { pauseAll(); uiPaused(); }
        {
            // Step 1: execute action `pauseAll(); uiPaused();`
            pauseAll(); uiPaused();
        } // end of behavior for PAUSED
    }
    
    #PAUSED_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #PAUSED_replay()
    {
        // PAUSED behavior
        // uml: REPLAY TransitionTo(REPLAYING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `REPLAYING`.
            this.#REPLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    #PAUSED_resume_all()
    {
        // PAUSED behavior
        // uml: RESUME_ALL TransitionTo(PLAYING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PLAYING`.
            this.#PLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYING
    ////////////////////////////////////////////////////////////////////////////////
    
    #PLAYING_enter()
    {
        this.stateId = AudioSm.StateId.PLAYING;
        
        // PLAYING behavior
        // uml: enter / { startMusic(); startAmbient(); syncAll(); uiPlaying(); }
        {
            // Step 1: execute action `startMusic(); startAmbient(); syncAll(); uiPlaying();`
            startMusic(); startAmbient(); syncAll(); uiPlaying();
        } // end of behavior for PLAYING
    }
    
    #PLAYING_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #PLAYING_mute_ambient()
    {
        // PLAYING behavior
        // uml: MUTE_AMBIENT / { muteAmbient(); }
        {
            // Step 1: execute action `muteAmbient();`
            muteAmbient();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_mute_music()
    {
        // PLAYING behavior
        // uml: MUTE_MUSIC / { muteMusic(); }
        {
            // Step 1: execute action `muteMusic();`
            muteMusic();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_pause_all()
    {
        // PLAYING behavior
        // uml: PAUSE_ALL TransitionTo(PAUSED)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PAUSED`.
            this.#PAUSED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_replay()
    {
        // PLAYING behavior
        // uml: REPLAY TransitionTo(REPLAYING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `REPLAYING`.
            this.#REPLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_unmute_ambient()
    {
        // PLAYING behavior
        // uml: UNMUTE_AMBIENT / { unmuteAmbient(); }
        {
            // Step 1: execute action `unmuteAmbient();`
            unmuteAmbient();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_unmute_music()
    {
        // PLAYING behavior
        // uml: UNMUTE_MUSIC / { unmuteMusic(); }
        {
            // Step 1: execute action `unmuteMusic();`
            unmuteMusic();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state REPLAYING
    ////////////////////////////////////////////////////////////////////////////////
    
    #REPLAYING_enter()
    {
        this.stateId = AudioSm.StateId.REPLAYING;
        
        // REPLAYING behavior
        // uml: enter / { restartSpeech(); uiLoading(); }
        {
            // Step 1: execute action `restartSpeech(); uiLoading();`
            restartSpeech(); uiLoading();
        } // end of behavior for REPLAYING
    }
    
    #REPLAYING_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #REPLAYING_speech_ready()
    {
        // REPLAYING behavior
        // uml: SPEECH_READY TransitionTo(PLAYING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#REPLAYING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PLAYING`.
            this.#PLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for REPLAYING
        
        // No ancestor handles this event.
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case AudioSm.StateId.ROOT: return "ROOT";
            case AudioSm.StateId.PLAYER: return "PLAYER";
            case AudioSm.StateId.IDLE: return "IDLE";
            case AudioSm.StateId.LOADING: return "LOADING";
            case AudioSm.StateId.PAUSED: return "PAUSED";
            case AudioSm.StateId.PLAYING: return "PLAYING";
            case AudioSm.StateId.REPLAYING: return "REPLAYING";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case AudioSm.EventId.MUTE_AMBIENT: return "MUTE_AMBIENT";
            case AudioSm.EventId.MUTE_MUSIC: return "MUTE_MUSIC";
            case AudioSm.EventId.PAUSE_ALL: return "PAUSE_ALL";
            case AudioSm.EventId.PLAY: return "PLAY";
            case AudioSm.EventId.REPLAY: return "REPLAY";
            case AudioSm.EventId.RESUME_ALL: return "RESUME_ALL";
            case AudioSm.EventId.SPEECH_READY: return "SPEECH_READY";
            case AudioSm.EventId.UNMUTE_AMBIENT: return "UNMUTE_AMBIENT";
            case AudioSm.EventId.UNMUTE_MUSIC: return "UNMUTE_MUSIC";
            default: return "?";
        }
    }
}
