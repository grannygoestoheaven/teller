// Autogenerated with StateSmith 0.19.0+b5719011215d41a81572ed347c02b22db5d1a48f.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class AudioSm
{
    static EventId = 
    {
        LAUNCH_STORY_PROCESS : 0,
        MUTE_AMBIENT : 1,
        MUTE_MUSIC : 2,
        PAUSE : 3,
        REPLAY : 4,
        RESUME : 5,
        SPEECH_READY : 6,
        STOP : 7,
        UNMUTE_AMBIENT : 8,
        UNMUTE_MUSIC : 9,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 10;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        PLAYER : 1,
        IDLE : 2,
        LOADING : 3,
        PLAYING : 4,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 5;
    static { Object.freeze(this.StateIdCount); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: TransitionTo(PLAYER)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PLAYER`.
                this.#PLAYER_enter();
                
                // PLAYER.<InitialState> behavior
                // uml: TransitionTo(IDLE)
                {
                    // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `IDLE`.
                    this.#IDLE_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    return;
                } // end of behavior for PLAYER.<InitialState>
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: AudioSm
            case AudioSm.StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: PLAYER
            case AudioSm.StateId.PLAYER:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: IDLE
            case AudioSm.StateId.IDLE:
                switch (eventId)
                {
                    case AudioSm.EventId.LAUNCH_STORY_PROCESS: this.#IDLE_launch_story_process(); break;
                }
                break;
            
            // STATE: LOADING
            case AudioSm.StateId.LOADING:
                switch (eventId)
                {
                    case AudioSm.EventId.STOP: this.#LOADING_stop(); break;
                    case AudioSm.EventId.SPEECH_READY: this.#LOADING_speech_ready(); break;
                }
                break;
            
            // STATE: PLAYING
            case AudioSm.StateId.PLAYING:
                switch (eventId)
                {
                    case AudioSm.EventId.REPLAY: this.#PLAYING_replay(); break;
                    case AudioSm.EventId.PAUSE: this.#PLAYING_pause(); break;
                    case AudioSm.EventId.RESUME: this.#PLAYING_resume(); break;
                    case AudioSm.EventId.MUTE_MUSIC: this.#PLAYING_mute_music(); break;
                    case AudioSm.EventId.UNMUTE_MUSIC: this.#PLAYING_unmute_music(); break;
                    case AudioSm.EventId.MUTE_AMBIENT: this.#PLAYING_mute_ambient(); break;
                    case AudioSm.EventId.UNMUTE_AMBIENT: this.#PLAYING_unmute_ambient(); break;
                    case AudioSm.EventId.STOP: this.#PLAYING_stop(); break;
                }
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case AudioSm.StateId.PLAYER: this.#PLAYER_exit(); break;
                
                case AudioSm.StateId.IDLE: this.#IDLE_exit(); break;
                
                case AudioSm.StateId.LOADING: this.#LOADING_exit(); break;
                
                case AudioSm.StateId.PLAYING: this.#PLAYING_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        this.stateId = AudioSm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYER
    ////////////////////////////////////////////////////////////////////////////////
    
    #PLAYER_enter()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #PLAYER_exit()
    {
        this.stateId = AudioSm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IDLE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IDLE_enter()
    {
        this.stateId = AudioSm.StateId.IDLE;
        
        // IDLE behavior
        // uml: enter / { stopAll(); uiIdle(); }
        {
            // Step 1: execute action `stopAll(); uiIdle();`
            stopAll(); uiIdle();
        } // end of behavior for IDLE
    }
    
    #IDLE_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #IDLE_launch_story_process()
    {
        // IDLE behavior
        // uml: LAUNCH_STORY_PROCESS TransitionTo(LOADING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#IDLE_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `LOADING`.
            this.#LOADING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IDLE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state LOADING
    ////////////////////////////////////////////////////////////////////////////////
    
    #LOADING_enter()
    {
        this.stateId = AudioSm.StateId.LOADING;
        
        // LOADING behavior
        // uml: enter / { loadingSpeech(); loadingUi(); }
        {
            // Step 1: execute action `loadingSpeech(); loadingUi();`
            loadingSpeech(); loadingUi();
        } // end of behavior for LOADING
    }
    
    #LOADING_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #LOADING_speech_ready()
    {
        // LOADING behavior
        // uml: SPEECH_READY TransitionTo(PLAYING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#LOADING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PLAYING`.
            this.#PLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for LOADING
        
        // No ancestor handles this event.
    }
    
    #LOADING_stop()
    {
        // LOADING behavior
        // uml: STOP TransitionTo(IDLE)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#LOADING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `IDLE`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for LOADING
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYING
    ////////////////////////////////////////////////////////////////////////////////
    
    #PLAYING_enter()
    {
        this.stateId = AudioSm.StateId.PLAYING;
        
        // PLAYING behavior
        // uml: enter / { startSpeech(); startMusic(); startAmbient(); syncAll(); uiPlaying(); }
        {
            // Step 1: execute action `startSpeech(); startMusic(); startAmbient(); syncAll(); uiPlaying();`
            startSpeech(); startMusic(); startAmbient(); syncAll(); uiPlaying();
        } // end of behavior for PLAYING
    }
    
    #PLAYING_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #PLAYING_mute_ambient()
    {
        // PLAYING behavior
        // uml: MUTE_AMBIENT / { muteAmbient(); }
        {
            // Step 1: execute action `muteAmbient();`
            muteAmbient();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_mute_music()
    {
        // PLAYING behavior
        // uml: MUTE_MUSIC / { muteMusic(); }
        {
            // Step 1: execute action `muteMusic();`
            muteMusic();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_pause()
    {
        // PLAYING behavior
        // uml: PAUSE / { pauseAll(); blurDots(); }
        {
            // Step 1: execute action `pauseAll(); blurDots();`
            pauseAll(); blurDots();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_replay()
    {
        // PLAYING behavior
        // uml: REPLAY / { startSpeech(); startMusic(); uiPlaying(); }
        {
            // Step 1: execute action `startSpeech(); startMusic(); uiPlaying();`
            startSpeech(); startMusic(); uiPlaying();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_resume()
    {
        // PLAYING behavior
        // uml: RESUME / { resumeAll(); unblurDots(); }
        {
            // Step 1: execute action `resumeAll(); unblurDots();`
            resumeAll(); unblurDots();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_stop()
    {
        // PLAYING behavior
        // uml: STOP TransitionTo(IDLE)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `IDLE`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_unmute_ambient()
    {
        // PLAYING behavior
        // uml: UNMUTE_AMBIENT / { unmuteAmbient(); }
        {
            // Step 1: execute action `unmuteAmbient();`
            unmuteAmbient();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_unmute_music()
    {
        // PLAYING behavior
        // uml: UNMUTE_MUSIC / { unmuteMusic(); }
        {
            // Step 1: execute action `unmuteMusic();`
            unmuteMusic();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case AudioSm.StateId.ROOT: return "ROOT";
            case AudioSm.StateId.PLAYER: return "PLAYER";
            case AudioSm.StateId.IDLE: return "IDLE";
            case AudioSm.StateId.LOADING: return "LOADING";
            case AudioSm.StateId.PLAYING: return "PLAYING";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case AudioSm.EventId.LAUNCH_STORY_PROCESS: return "LAUNCH_STORY_PROCESS";
            case AudioSm.EventId.MUTE_AMBIENT: return "MUTE_AMBIENT";
            case AudioSm.EventId.MUTE_MUSIC: return "MUTE_MUSIC";
            case AudioSm.EventId.PAUSE: return "PAUSE";
            case AudioSm.EventId.REPLAY: return "REPLAY";
            case AudioSm.EventId.RESUME: return "RESUME";
            case AudioSm.EventId.SPEECH_READY: return "SPEECH_READY";
            case AudioSm.EventId.STOP: return "STOP";
            case AudioSm.EventId.UNMUTE_AMBIENT: return "UNMUTE_AMBIENT";
            case AudioSm.EventId.UNMUTE_MUSIC: return "UNMUTE_MUSIC";
            default: return "?";
        }
    }
}
