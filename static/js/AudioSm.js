// Autogenerated with StateSmith 0.19.0+b5719011215d41a81572ed347c02b22db5d1a48f.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class AudioSm
{
    static EventId = 
    {
        CANCEL : 0,
        FORM_NOT_EMPTY : 1,
        PLAY_BTN_CLICKED : 2,
        REPLAY_BTN_CLICKED : 3,
        SPEECH_OVER : 4,
        SPEECH_READY : 5,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 6;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        PLAYER : 1,
        IDLE : 2,
        LOADING : 3,
        PAUSED : 4,
        PLAYING : 5,
        READY : 6,
        REPLAYING : 7,
        TEXT_DISPLAYED : 8,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 9;
    static { Object.freeze(this.StateIdCount); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: TransitionTo(PLAYER)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PLAYER`.
                this.#PLAYER_enter();
                
                // PLAYER.<InitialState> behavior
                // uml: TransitionTo(IDLE)
                {
                    // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                    
                    // Step 2: Transition action: ``.
                    
                    // Step 3: Enter/move towards transition target `IDLE`.
                    this.#IDLE_enter();
                    
                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    return;
                } // end of behavior for PLAYER.<InitialState>
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: AudioSm
            case AudioSm.StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: PLAYER
            case AudioSm.StateId.PLAYER:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: IDLE
            case AudioSm.StateId.IDLE:
                switch (eventId)
                {
                    case AudioSm.EventId.FORM_NOT_EMPTY: this.#IDLE_form_not_empty(); break;
                }
                break;
            
            // STATE: LOADING
            case AudioSm.StateId.LOADING:
                switch (eventId)
                {
                    case AudioSm.EventId.SPEECH_READY: this.#LOADING_speech_ready(); break;
                    case AudioSm.EventId.CANCEL: this.#LOADING_cancel(); break;
                }
                break;
            
            // STATE: PAUSED
            case AudioSm.StateId.PAUSED:
                switch (eventId)
                {
                    case AudioSm.EventId.PLAY_BTN_CLICKED: this.#PAUSED_play_btn_clicked(); break;
                    case AudioSm.EventId.REPLAY_BTN_CLICKED: this.#PAUSED_replay_btn_clicked(); break;
                    case AudioSm.EventId.FORM_NOT_EMPTY: this.#PAUSED_form_not_empty(); break;
                    case AudioSm.EventId.CANCEL: this.#PAUSED_cancel(); break;
                }
                break;
            
            // STATE: PLAYING
            case AudioSm.StateId.PLAYING:
                switch (eventId)
                {
                    case AudioSm.EventId.PLAY_BTN_CLICKED: this.#PLAYING_play_btn_clicked(); break;
                    case AudioSm.EventId.FORM_NOT_EMPTY: this.#PLAYING_form_not_empty(); break;
                    case AudioSm.EventId.CANCEL: this.#PLAYING_cancel(); break;
                    case AudioSm.EventId.SPEECH_OVER: this.#PLAYING_speech_over(); break;
                }
                break;
            
            // STATE: READY
            case AudioSm.StateId.READY:
                switch (eventId)
                {
                    case AudioSm.EventId.PLAY_BTN_CLICKED: this.#READY_play_btn_clicked(); break;
                }
                break;
            
            // STATE: REPLAYING
            case AudioSm.StateId.REPLAYING:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: TEXT_DISPLAYED
            case AudioSm.StateId.TEXT_DISPLAYED:
                // No events handled by this state (or its ancestors).
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case AudioSm.StateId.PLAYER: this.#PLAYER_exit(); break;
                
                case AudioSm.StateId.IDLE: this.#IDLE_exit(); break;
                
                case AudioSm.StateId.LOADING: this.#LOADING_exit(); break;
                
                case AudioSm.StateId.PAUSED: this.#PAUSED_exit(); break;
                
                case AudioSm.StateId.PLAYING: this.#PLAYING_exit(); break;
                
                case AudioSm.StateId.READY: this.#READY_exit(); break;
                
                case AudioSm.StateId.REPLAYING: this.#REPLAYING_exit(); break;
                
                case AudioSm.StateId.TEXT_DISPLAYED: this.#TEXT_DISPLAYED_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        this.stateId = AudioSm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYER
    ////////////////////////////////////////////////////////////////////////////////
    
    #PLAYER_enter()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #PLAYER_exit()
    {
        this.stateId = AudioSm.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IDLE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IDLE_enter()
    {
        this.stateId = AudioSm.StateId.IDLE;
    }
    
    #IDLE_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #IDLE_form_not_empty()
    {
        // IDLE behavior
        // uml: FORM_NOT_EMPTY TransitionTo(READY)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#IDLE_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `READY`.
            this.#READY_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IDLE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state LOADING
    ////////////////////////////////////////////////////////////////////////////////
    
    #LOADING_enter()
    {
        this.stateId = AudioSm.StateId.LOADING;
    }
    
    #LOADING_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #LOADING_cancel()
    {
        // LOADING behavior
        // uml: CANCEL TransitionTo(IDLE)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#LOADING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `IDLE`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for LOADING
        
        // No ancestor handles this event.
    }
    
    #LOADING_speech_ready()
    {
        // LOADING behavior
        // uml: SPEECH_READY TransitionTo(PLAYING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#LOADING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PLAYING`.
            this.#PLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for LOADING
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PAUSED
    ////////////////////////////////////////////////////////////////////////////////
    
    #PAUSED_enter()
    {
        this.stateId = AudioSm.StateId.PAUSED;
    }
    
    #PAUSED_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #PAUSED_cancel()
    {
        // PAUSED behavior
        // uml: CANCEL TransitionTo(IDLE)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `IDLE`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    #PAUSED_form_not_empty()
    {
        // PAUSED behavior
        // uml: FORM_NOT_EMPTY TransitionTo(READY)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `READY`.
            this.#READY_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    #PAUSED_play_btn_clicked()
    {
        // PAUSED behavior
        // uml: PLAY_BTN_CLICKED TransitionTo(PLAYING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PLAYING`.
            this.#PLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    #PAUSED_replay_btn_clicked()
    {
        // PAUSED behavior
        // uml: REPLAY_BTN_CLICKED TransitionTo(REPLAYING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `REPLAYING`.
            this.#REPLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYING
    ////////////////////////////////////////////////////////////////////////////////
    
    #PLAYING_enter()
    {
        this.stateId = AudioSm.StateId.PLAYING;
    }
    
    #PLAYING_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #PLAYING_cancel()
    {
        // PLAYING behavior
        // uml: CANCEL TransitionTo(IDLE)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `IDLE`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_form_not_empty()
    {
        // PLAYING behavior
        // uml: FORM_NOT_EMPTY TransitionTo(READY)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `READY`.
            this.#READY_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_play_btn_clicked()
    {
        // PLAYING behavior
        // uml: PLAY_BTN_CLICKED TransitionTo(PAUSED)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PAUSED`.
            this.#PAUSED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_speech_over()
    {
        // PLAYING behavior
        // uml: SPEECH_OVER TransitionTo(TEXT_DISPLAYED)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `TEXT_DISPLAYED`.
            this.#TEXT_DISPLAYED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READY
    ////////////////////////////////////////////////////////////////////////////////
    
    #READY_enter()
    {
        this.stateId = AudioSm.StateId.READY;
    }
    
    #READY_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    #READY_play_btn_clicked()
    {
        // READY behavior
        // uml: PLAY_BTN_CLICKED TransitionTo(LOADING)
        {
            // Step 1: Exit states until we reach `PLAYER` state (Least Common Ancestor for transition).
            this.#READY_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `LOADING`.
            this.#LOADING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for READY
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state REPLAYING
    ////////////////////////////////////////////////////////////////////////////////
    
    #REPLAYING_enter()
    {
        this.stateId = AudioSm.StateId.REPLAYING;
    }
    
    #REPLAYING_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TEXT_DISPLAYED
    ////////////////////////////////////////////////////////////////////////////////
    
    #TEXT_DISPLAYED_enter()
    {
        this.stateId = AudioSm.StateId.TEXT_DISPLAYED;
    }
    
    #TEXT_DISPLAYED_exit()
    {
        this.stateId = AudioSm.StateId.PLAYER;
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case AudioSm.StateId.ROOT: return "ROOT";
            case AudioSm.StateId.PLAYER: return "PLAYER";
            case AudioSm.StateId.IDLE: return "IDLE";
            case AudioSm.StateId.LOADING: return "LOADING";
            case AudioSm.StateId.PAUSED: return "PAUSED";
            case AudioSm.StateId.PLAYING: return "PLAYING";
            case AudioSm.StateId.READY: return "READY";
            case AudioSm.StateId.REPLAYING: return "REPLAYING";
            case AudioSm.StateId.TEXT_DISPLAYED: return "TEXT_DISPLAYED";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case AudioSm.EventId.CANCEL: return "CANCEL";
            case AudioSm.EventId.FORM_NOT_EMPTY: return "FORM_NOT_EMPTY";
            case AudioSm.EventId.PLAY_BTN_CLICKED: return "PLAY_BTN_CLICKED";
            case AudioSm.EventId.REPLAY_BTN_CLICKED: return "REPLAY_BTN_CLICKED";
            case AudioSm.EventId.SPEECH_OVER: return "SPEECH_OVER";
            case AudioSm.EventId.SPEECH_READY: return "SPEECH_READY";
            default: return "?";
        }
    }
}
