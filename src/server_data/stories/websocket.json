{
    "subject": "WebSocket (Onramp)",
    "raw": "WebSocket. <[silence]> Full-duplex. <[silence]> Persistent. <[silence]> Real-time. <[silence]>\n\nWebSocket solves the gap in HTTP for low-latency, bidirectional messaging. <[silence]> It creates a persistent TCP connection after an HTTP upgrade, avoiding per-message handshakes. <[silence]> The client sends an Upgrade request; the server replies with 101 Switching Protocols. <[silence]> After that, both sides exchange framed messages, text or binary. <[silence]> The lifecycle exposes events: open, message, error, close. <[silence]> Use wss on HTTPS origins to protect traffic and pass proxies. <[silence]> Heartbeats with ping and pong keep intermediaries from idling out the link. <[silence]> Reconnection needs backoff and resubscription logic. <[silence]> Prefer SSE when you only need server-to-client events; prefer polling for rare updates and simple hosting. <[silence]> Watch for proxies dropping idle connections, load balancers without stickiness, and oversized frames. <[silence]>\n\nEnd-to-end echo run. <[silence]> The browser resolves DNS and negotiates TLS for wss. <[silence]> It issues an HTTP GET with Upgrade: websocket and Sec-WebSocket-Key. <[silence]> The server validates and returns 101 with Sec-WebSocket-Accept. <[silence]> The open event fires; the client queues a small text frame 'hello'. <[silence]> The server echoes the frame; a message event delivers it to the page. <[silence]> The connection sits idle; the server sends periodic ping; the client replies pong automatically. <[silence]> A load balancer with a short idle timeout is present; heartbeats prevent closure. <[silence]> The user clicks close; the client sends a close frame with code 1000. <[silence]> The server responds with a close; the close event fires and resources are released. <[silence]>\n\nYour turn—fill the blanks mentally. <[silence]> 1) Handshake upgrades from ___ to ___ with status ___. <[silence]> 2) After open, messages travel as ___, not raw TCP bytes. <[silence]> 3) Idle links stay alive using ___/___ frames. <[silence]> 4) Secure deployments use the scheme ___. <[silence]> 5) One-way server push only? Prefer ___. <[silence]> 6) Rare updates on basic hosting? Consider ___. <[silence]> 7) Clean shutdown sends a ___ frame with code ___. <[silence]>\n\nQuick check. <[silence]> Q1: What HTTP status finalizes the upgrade? <[silence]> Q2: Why is WebSocket low-latency compared to long polling? <[silence]> Q3: Name the four lifecycle events. <[silence]> Q4: What maintains long-lived links through intermediaries? <[silence]> Q5: When is SSE a better choice? <[silence]> Q6: Name two common infrastructure pitfalls. <[silence]>\nAnswers: <[silence]> A1: 101 Switching Protocols. <[silence]> A2: Persistent connection removes per-message request/response overhead. <[silence]> A3: open, message, error, close. <[silence]> A4: ping and pong heartbeats. <[silence]> A5: Server-to-client only streams. <[silence]> A6: Idle timeouts on proxies or load balancers, and missing stickiness. <[silence]>\n\nThree related subjects are Server-Sent Events, HTTP/2 streaming, and long polling. <[silence]>",
    "clean": "WebSocket. Full-duplex. Persistent. Real-time. WebSocket solves the gap in HTTP for low-latency, bidirectional messaging. It creates a persistent TCP connection after an HTTP upgrade, avoiding per-message handshakes. The client sends an Upgrade request; the server replies with 101 Switching Protocols. After that, both sides exchange framed messages, text or binary. The lifecycle exposes events: open, message, error, close. Use wss on HTTPS origins to protect traffic and pass proxies. Heartbeats with ping and pong keep intermediaries from idling out the link. Reconnection needs backoff and resubscription logic. Prefer SSE when you only need server-to-client events; prefer polling for rare updates and simple hosting. Watch for proxies dropping idle connections, load balancers without stickiness, and oversized frames. End-to-end echo run. The browser resolves DNS and negotiates TLS for wss. It issues an HTTP GET with Upgrade: websocket and Sec-WebSocket-Key. The server validates and returns 101 with Sec-WebSocket-Accept. The open event fires; the client queues a small text frame 'hello'. The server echoes the frame; a message event delivers it to the page. The connection sits idle; the server sends periodic ping; the client replies pong automatically. A load balancer with a short idle timeout is present; heartbeats prevent closure. The user clicks close; the client sends a close frame with code 1000. The server responds with a close; the close event fires and resources are released. Your turn—fill the blanks mentally. 1) Handshake upgrades from ___ to ___ with status ___. 2) After open, messages travel as ___, not raw TCP bytes. 3) Idle links stay alive using ___/___ frames. 4) Secure deployments use the scheme ___. 5) One-way server push only? Prefer ___. 6) Rare updates on basic hosting? Consider ___. 7) Clean shutdown sends a ___ frame with code ___. Quick check. Q1: What HTTP status finalizes the upgrade? Q2: Why is WebSocket low-latency compared to long polling? Q3: Name the four lifecycle events. Q4: What maintains long-lived links through intermediaries? Q5: When is SSE a better choice? Q6: Name two common infrastructure pitfalls. Answers: A1: 101 Switching Protocols. A2: Persistent connection removes per-message request/response overhead. A3: open, message, error, close. A4: ping and pong heartbeats. A5: Server-to-client only streams. A6: Idle timeouts on proxies or load balancers, and missing stickiness. Three related subjects are Server-Sent Events, HTTP/2 streaming, and long polling.",
    "timestamp": "20250823T000000Z"
  }
  