// Autogenerated with StateSmith 0.19.0+b5719011215d41a81572ed347c02b22db5d1a48f.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Generated state machine
class AudioStateMachine
{
    static EventId = 
    {
        CANCEL : 0,
        CHAT_HISTORY_CLICKED : 1,
        FROM_START_CLICKED : 2,
        INPUT_CHANGED : 3,
        MUSIC_OVER : 4,
        SPEECH_OVER : 5,
        SPEECH_READY : 6,
        SQUARE_CLICKED : 7,
        TOGGLE_PAUSE_RESUME : 8,
        VIEW_TOGGLED : 9,
    }
    static { Object.freeze(this.EventId); }
    
    static EventIdCount = 10;
    static { Object.freeze(this.EventIdCount); }
    
    static StateId = 
    {
        ROOT : 0,
        IDLE : 1,
        LOADING : 2,
        PAUSED : 3,
        PLAYING : 4,
        READY : 5,
    }
    static { Object.freeze(this.StateId); }
    
    static StateIdCount = 6;
    static { Object.freeze(this.StateIdCount); }
    
    // Used internally by state machine. Feel free to inspect, but don't modify.
    stateId;
    
    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    start()
    {
        this.#ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
            
            // ROOT.<InitialState> behavior
            // uml: TransitionTo(IDLE)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `IDLE`.
                this.#IDLE_enter();
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }
    
    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    dispatchEvent(eventId)
    {
        switch (this.stateId)
        {
            // STATE: AudioStateMachine
            case AudioStateMachine.StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;
            
            // STATE: IDLE
            case AudioStateMachine.StateId.IDLE:
                switch (eventId)
                {
                    case AudioStateMachine.EventId.SQUARE_CLICKED: this.#IDLE_square_clicked(); break;
                    case AudioStateMachine.EventId.TOGGLE_PAUSE_RESUME: this.#IDLE_toggle_pause_resume(); break;
                }
                break;
            
            // STATE: LOADING
            case AudioStateMachine.StateId.LOADING:
                switch (eventId)
                {
                    case AudioStateMachine.EventId.SPEECH_READY: this.#LOADING_speech_ready(); break;
                    case AudioStateMachine.EventId.TOGGLE_PAUSE_RESUME: this.#LOADING_toggle_pause_resume(); break;
                    case AudioStateMachine.EventId.CANCEL: this.#LOADING_cancel(); break;
                }
                break;
            
            // STATE: PAUSED
            case AudioStateMachine.StateId.PAUSED:
                switch (eventId)
                {
                    case AudioStateMachine.EventId.VIEW_TOGGLED: this.#PAUSED_view_toggled(); break;
                    case AudioStateMachine.EventId.TOGGLE_PAUSE_RESUME: this.#PAUSED_toggle_pause_resume(); break;
                    case AudioStateMachine.EventId.FROM_START_CLICKED: this.#PAUSED_from_start_clicked(); break;
                    case AudioStateMachine.EventId.INPUT_CHANGED: this.#PAUSED_input_changed(); break;
                    case AudioStateMachine.EventId.CANCEL: this.#PAUSED_cancel(); break;
                }
                break;
            
            // STATE: PLAYING
            case AudioStateMachine.StateId.PLAYING:
                switch (eventId)
                {
                    case AudioStateMachine.EventId.VIEW_TOGGLED: this.#PLAYING_view_toggled(); break;
                    case AudioStateMachine.EventId.CHAT_HISTORY_CLICKED: this.#PLAYING_chat_history_clicked(); break;
                    case AudioStateMachine.EventId.FROM_START_CLICKED: this.#PLAYING_from_start_clicked(); break;
                    case AudioStateMachine.EventId.SPEECH_OVER: this.#PLAYING_speech_over(); break;
                    case AudioStateMachine.EventId.TOGGLE_PAUSE_RESUME: this.#PLAYING_toggle_pause_resume(); break;
                    case AudioStateMachine.EventId.MUSIC_OVER: this.#PLAYING_music_over(); break;
                    case AudioStateMachine.EventId.SQUARE_CLICKED: this.#PLAYING_square_clicked(); break;
                    case AudioStateMachine.EventId.CANCEL: this.#PLAYING_cancel(); break;
                }
                break;
            
            // STATE: READY
            case AudioStateMachine.StateId.READY:
                // No events handled by this state (or its ancestors).
                break;
        }
        
    }
    
    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    #exitUpToStateHandler(desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case AudioStateMachine.StateId.IDLE: this.#IDLE_exit(); break;
                
                case AudioStateMachine.StateId.LOADING: this.#LOADING_exit(); break;
                
                case AudioStateMachine.StateId.PAUSED: this.#PAUSED_exit(); break;
                
                case AudioStateMachine.StateId.PLAYING: this.#PLAYING_exit(); break;
                
                case AudioStateMachine.StateId.READY: this.#READY_exit(); break;
                
                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////
    
    #ROOT_enter()
    {
        this.stateId = AudioStateMachine.StateId.ROOT;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IDLE
    ////////////////////////////////////////////////////////////////////////////////
    
    #IDLE_enter()
    {
        this.stateId = AudioStateMachine.StateId.IDLE;
        
        // IDLE behavior
        // uml: enter / { this.actions.pauseAllAudio(); this.actions.resetAllAudio(); this.actions.uiIdle(); this.actions.hideLoadingAnimation(); this.actions.initInputAdjustments(); }
        {
            // Step 1: execute action `this.actions.pauseAllAudio(); this.actions.resetAllAudio(); this.actions.uiIdle(); this.actions.hideLoadingAnimation(); this.actions.initInputAdjustments();`
            this.actions.pauseAllAudio(); this.actions.resetAllAudio(); this.actions.uiIdle(); this.actions.hideLoadingAnimation(); this.actions.initInputAdjustments();
        } // end of behavior for IDLE
    }
    
    #IDLE_exit()
    {
        this.stateId = AudioStateMachine.StateId.ROOT;
    }
    
    #IDLE_square_clicked()
    {
        // IDLE behavior
        // uml: SQUARE_CLICKED / { this.actions.startNewStoryProcess(); } TransitionTo(LOADING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#IDLE_exit();
            
            // Step 2: Transition action: `this.actions.startNewStoryProcess();`.
            this.actions.startNewStoryProcess();
            
            // Step 3: Enter/move towards transition target `LOADING`.
            this.#LOADING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IDLE
        
        // No ancestor handles this event.
    }
    
    #IDLE_toggle_pause_resume()
    {
        // IDLE behavior
        // uml: TOGGLE_PAUSE_RESUME / { this.actions.startNewStoryProcess(); } TransitionTo(LOADING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#IDLE_exit();
            
            // Step 2: Transition action: `this.actions.startNewStoryProcess();`.
            this.actions.startNewStoryProcess();
            
            // Step 3: Enter/move towards transition target `LOADING`.
            this.#LOADING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IDLE
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state LOADING
    ////////////////////////////////////////////////////////////////////////////////
    
    #LOADING_enter()
    {
        this.stateId = AudioStateMachine.StateId.LOADING;
        
        // LOADING behavior
        // uml: enter / { this.actions.showLoadingAnimation(); this.actions.loadingDots(); this.actions.uiLoadingButtons(); this.actions.toggleView(); }
        {
            // Step 1: execute action `this.actions.showLoadingAnimation(); this.actions.loadingDots(); this.actions.uiLoadingButtons(); this.actions.toggleView();`
            this.actions.showLoadingAnimation(); this.actions.loadingDots(); this.actions.uiLoadingButtons(); this.actions.toggleView();
        } // end of behavior for LOADING
    }
    
    #LOADING_exit()
    {
        this.stateId = AudioStateMachine.StateId.ROOT;
    }
    
    #LOADING_cancel()
    {
        // LOADING behavior
        // uml: CANCEL / { this.actions.abortProcess(); } TransitionTo(IDLE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#LOADING_exit();
            
            // Step 2: Transition action: `this.actions.abortProcess();`.
            this.actions.abortProcess();
            
            // Step 3: Enter/move towards transition target `IDLE`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for LOADING
        
        // No ancestor handles this event.
    }
    
    #LOADING_speech_ready()
    {
        // LOADING behavior
        // uml: SPEECH_READY / { this.actions.setUpAndStartAllAudio(); } TransitionTo(PLAYING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#LOADING_exit();
            
            // Step 2: Transition action: `this.actions.setUpAndStartAllAudio();`.
            this.actions.setUpAndStartAllAudio();
            
            // Step 3: Enter/move towards transition target `PLAYING`.
            this.#PLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for LOADING
        
        // No ancestor handles this event.
    }
    
    #LOADING_toggle_pause_resume()
    {
        // LOADING behavior
        // uml: TOGGLE_PAUSE_RESUME / { this.actions.pauseAllAudio(); } TransitionTo(PAUSED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#LOADING_exit();
            
            // Step 2: Transition action: `this.actions.pauseAllAudio();`.
            this.actions.pauseAllAudio();
            
            // Step 3: Enter/move towards transition target `PAUSED`.
            this.#PAUSED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for LOADING
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PAUSED
    ////////////////////////////////////////////////////////////////////////////////
    
    #PAUSED_enter()
    {
        this.stateId = AudioStateMachine.StateId.PAUSED;
        
        // PAUSED behavior
        // uml: enter / { this.actions.uiPausedButtons(); this.actions.addBlurr(); }
        {
            // Step 1: execute action `this.actions.uiPausedButtons(); this.actions.addBlurr();`
            this.actions.uiPausedButtons(); this.actions.addBlurr();
        } // end of behavior for PAUSED
    }
    
    #PAUSED_exit()
    {
        this.stateId = AudioStateMachine.StateId.ROOT;
    }
    
    #PAUSED_cancel()
    {
        // PAUSED behavior
        // uml: CANCEL / { this.actions.setUpAndStartAllAudio(); } TransitionTo(IDLE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: `this.actions.setUpAndStartAllAudio();`.
            this.actions.setUpAndStartAllAudio();
            
            // Step 3: Enter/move towards transition target `IDLE`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    #PAUSED_from_start_clicked()
    {
        // PAUSED behavior
        // uml: FROM_START_CLICKED / { this.actions.resetAllAudio(); this.actions.setUpAndStartAllAudio(); } TransitionTo(PLAYING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: `this.actions.resetAllAudio(); this.actions.setUpAndStartAllAudio();`.
            this.actions.resetAllAudio(); this.actions.setUpAndStartAllAudio();
            
            // Step 3: Enter/move towards transition target `PLAYING`.
            this.#PLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    #PAUSED_input_changed()
    {
        // PAUSED behavior
        // uml: INPUT_CHANGED [this.actions.inputIsValid()] TransitionTo(READY)
        if (this.actions.inputIsValid())
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `READY`.
            this.#READY_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    #PAUSED_toggle_pause_resume()
    {
        // PAUSED behavior
        // uml: TOGGLE_PAUSE_RESUME / { this.actions.resumeAllAudio(); } TransitionTo(PLAYING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PAUSED_exit();
            
            // Step 2: Transition action: `this.actions.resumeAllAudio();`.
            this.actions.resumeAllAudio();
            
            // Step 3: Enter/move towards transition target `PLAYING`.
            this.#PLAYING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    #PAUSED_view_toggled()
    {
        // PAUSED behavior
        // uml: VIEW_TOGGLED / { this.actions.toggleView() }
        {
            // Step 1: execute action `this.actions.toggleView()`
            this.actions.toggleView()
        } // end of behavior for PAUSED
        
        // PAUSED behavior
        // uml: VIEW_TOGGLED [this.actions.getIsGridVisible] / { this.actions.dotsViewTitle(); }
        if (this.actions.getIsGridVisible)
        {
            // Step 1: execute action `this.actions.dotsViewTitle();`
            this.actions.dotsViewTitle();
        } // end of behavior for PAUSED
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYING
    ////////////////////////////////////////////////////////////////////////////////
    
    #PLAYING_enter()
    {
        this.stateId = AudioStateMachine.StateId.PLAYING;
        
        // PLAYING behavior
        // uml: enter / { this.actions.uiPlayingButtons(); this.actions.removeBlurr(); this.actions.greenDots(); }
        {
            // Step 1: execute action `this.actions.uiPlayingButtons(); this.actions.removeBlurr(); this.actions.greenDots();`
            this.actions.uiPlayingButtons(); this.actions.removeBlurr(); this.actions.greenDots();
        } // end of behavior for PLAYING
    }
    
    #PLAYING_exit()
    {
        this.stateId = AudioStateMachine.StateId.ROOT;
    }
    
    #PLAYING_cancel()
    {
        // PLAYING behavior
        // uml: CANCEL / { this.actions.stopAndResetAllAudio(); } TransitionTo(IDLE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: `this.actions.stopAndResetAllAudio();`.
            this.actions.stopAndResetAllAudio();
            
            // Step 3: Enter/move towards transition target `IDLE`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_chat_history_clicked()
    {
        // PLAYING behavior
        // uml: CHAT_HISTORY_CLICKED / { this.actions.toggleTextVisibility(); }
        {
            // Step 1: execute action `this.actions.toggleTextVisibility();`
            this.actions.toggleTextVisibility();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_from_start_clicked()
    {
        // PLAYING behavior
        // uml: FROM_START_CLICKED / { this.actions.pauseAllAudio(); this.actions.resetAllAudio(); this.actions.setUpAndStartAllAudio(); }
        {
            // Step 1: execute action `this.actions.pauseAllAudio(); this.actions.resetAllAudio(); this.actions.setUpAndStartAllAudio();`
            this.actions.pauseAllAudio(); this.actions.resetAllAudio(); this.actions.setUpAndStartAllAudio();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_music_over()
    {
        // PLAYING behavior
        // uml: MUSIC_OVER [this.actions.bothTracksEnded()] TransitionTo(IDLE)
        if (this.actions.bothTracksEnded())
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `IDLE`.
            this.#IDLE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_speech_over()
    {
        // PLAYING behavior
        // uml: SPEECH_OVER / { this.actions.toggleView(); }
        {
            // Step 1: execute action `this.actions.toggleView();`
            this.actions.toggleView();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_square_clicked()
    {
        // PLAYING behavior
        // uml: SQUARE_CLICKED / { this.actions.startNewStoryProcess(); } TransitionTo(LOADING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: `this.actions.startNewStoryProcess();`.
            this.actions.startNewStoryProcess();
            
            // Step 3: Enter/move towards transition target `LOADING`.
            this.#LOADING_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_toggle_pause_resume()
    {
        // PLAYING behavior
        // uml: TOGGLE_PAUSE_RESUME / { this.actions.pauseAllAudio(); } TransitionTo(PAUSED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            this.#PLAYING_exit();
            
            // Step 2: Transition action: `this.actions.pauseAllAudio();`.
            this.actions.pauseAllAudio();
            
            // Step 3: Enter/move towards transition target `PAUSED`.
            this.#PAUSED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    #PLAYING_view_toggled()
    {
        // PLAYING behavior
        // uml: VIEW_TOGGLED / { this.actions.toggleView() }
        {
            // Step 1: execute action `this.actions.toggleView()`
            this.actions.toggleView()
        } // end of behavior for PLAYING
        
        // PLAYING behavior
        // uml: VIEW_TOGGLED [this.actions.getIsGridVisible] / { this.actions.dotsViewTitle(); }
        if (this.actions.getIsGridVisible)
        {
            // Step 1: execute action `this.actions.dotsViewTitle();`
            this.actions.dotsViewTitle();
        } // end of behavior for PLAYING
        
        // No ancestor handles this event.
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state READY
    ////////////////////////////////////////////////////////////////////////////////
    
    #READY_enter()
    {
        this.stateId = AudioStateMachine.StateId.READY;
    }
    
    #READY_exit()
    {
        this.stateId = AudioStateMachine.StateId.ROOT;
    }
    
    // Thread safe.
    static stateIdToString(id)
    {
        switch (id)
        {
            case AudioStateMachine.StateId.ROOT: return "ROOT";
            case AudioStateMachine.StateId.IDLE: return "IDLE";
            case AudioStateMachine.StateId.LOADING: return "LOADING";
            case AudioStateMachine.StateId.PAUSED: return "PAUSED";
            case AudioStateMachine.StateId.PLAYING: return "PLAYING";
            case AudioStateMachine.StateId.READY: return "READY";
            default: return "?";
        }
    }
    
    // Thread safe.
    static eventIdToString(id)
    {
        switch (id)
        {
            case AudioStateMachine.EventId.CANCEL: return "CANCEL";
            case AudioStateMachine.EventId.CHAT_HISTORY_CLICKED: return "CHAT_HISTORY_CLICKED";
            case AudioStateMachine.EventId.FROM_START_CLICKED: return "FROM_START_CLICKED";
            case AudioStateMachine.EventId.INPUT_CHANGED: return "INPUT_CHANGED";
            case AudioStateMachine.EventId.MUSIC_OVER: return "MUSIC_OVER";
            case AudioStateMachine.EventId.SPEECH_OVER: return "SPEECH_OVER";
            case AudioStateMachine.EventId.SPEECH_READY: return "SPEECH_READY";
            case AudioStateMachine.EventId.SQUARE_CLICKED: return "SQUARE_CLICKED";
            case AudioStateMachine.EventId.TOGGLE_PAUSE_RESUME: return "TOGGLE_PAUSE_RESUME";
            case AudioStateMachine.EventId.VIEW_TOGGLED: return "VIEW_TOGGLED";
            default: return "?";
        }
    }
}
